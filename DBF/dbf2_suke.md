# Debug For Fun

苏克

2016年3月31日

## 第二期：数组与指针

### 前言

C语言很容易让你在开枪时伤着自己的脚，C++使这种情况很少发生。但是，一旦发生这种情况，它很可能轰掉你整条腿。
    —— Bjarne Stroustrup（C++之父）

### 关于数组和指针：sizeof()

```C++
#include <stdio.h>
int main(void)
{
 char str[] = "world";
 char * pstr = "world";
 printf("%d %d",sizeof(str),sizeof(pstr));
 getchar();
 return 0;
}
```

如图所示的一段代码，它的输出是什么呢——请大家先自己猜测一个答案，然后再亲自验证一下，也许结果会让你大吃一惊！

函数sizeof()应该是返回其参数的“size”。但是它对于数组（用 char A[]形式定义）和指针（char* A 定义）的表现是截然不同的。

在上面的例子里，sizeof(str)的结果是6——这是字符串"world"的长度（别忘了后面还有一个表示结束的'\0'）。但是sizeof(pstr)的值却是4（32位编译器下的结果）——事实上，由于pstr是一个指针，sizeof并不能得到它究竟指向怎样的一个或者一段数据，所以只能返回这个指针自己的大小（在32位平台下结果是4），甚至和这个指针指向的元素类型无关。大家可以试试这样的一段代码：

```c++
void* p;
cout << sizeof(p) << endl;
```

其结果是4——一个指针变量的大小。从上面的例子之中我们可以看到，数组虽然和指针有着千丝万缕的联系，但实际使用时是有区别的，稍不小心便可能“轰掉你整条腿”——请看下面的例子，你能通过各种调试手段找到其中的问题么？

```c++
#include <stdio.h>
const int MAXN = 100;
int arr[MAXN];

void clear(int a[MAXN])
{
    memset(a, 0, sizeof(a));
}

int main()
{
    f(arr);
}
```

提示：我们可以猜测这段代码的用意是用函数clear来把数组arr中的所有元素清零。大家可以先通过输出arr的元素的方式来看他有没有达到自己的预想目的；再在函数clear()中输出一些调试信息来看他究竟犯了什么错误。

那之后，相信你就可以回答下面这个问题：

    当函数接受一个数组的名字作为参数时，函数体内部对这个参数的认知究竟是“数组”还是“指针”？

此外，你有什么好的方法可以帮助他解决这个问题么？请把你的结论和想法发表到讨论区和大家分享！优秀的回答将有可能被摘录进入课程讨论精华之中，供以后所有的学生参考。

### 下标[]

对于数组/指针来说，“取下标/取元素符号”a[i]永远被这样理解：*(a+i)。细心的同学会发现，这里面的“a+i”是一个指针类型和一个整数的加法运算。指针类型是如何和整数相加的？对于指向不同数据类型的指针，这个加法的运算规则又有什么不同？

请大家通过编写程序，得到恰当的输出信息，回答这个问题。请把你的结果发表到讨论区和大家一起分享！

## 参与到DBF模块的制作中来

作为管理DBF模块的助教，我希望可以给学有余力的同学们提供更多C++相关的，或者编程相关的知识、技巧。你对这个模块有什么期待？你想要看到关于什么内容的文章，想要更深入地了解哪些方面的技巧？请把你的宝贵意见发表到讨论区，参与到课程的制作中来！