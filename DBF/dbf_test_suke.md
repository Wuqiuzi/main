# Debug For Fun 之 调试的乐趣

苏克
2016-03-17

## 系列前言

OJ（*Online Judgement，在线评测系统*）是冰冷的机器，它会一丝不苟地将你程序所有不正确的地方指出，并返回给你一个冰冷的**Wrong Answer**。调试（Debug）本身就是编程过程中一个重要的部分——无论是课程里这些简单的小程序，还是具有复杂架构的工程项目，都可能需要程序员在调试上花费很多精力。

笔者在初学C++编程时，也曾经为了改正一个小小的问题冥思苦想很久，最后找出问题所在的一刻才恍然大悟——这种豁然开朗的成就感也算是编程的乐趣所在吧！在这个模块里，笔者希望可以通过一些简单的题目来向大家展示C++初学者（或者编程初学者）容易犯的错误，以及一些好用的编程技巧。

## 第一期：边界情况（Cornor  Case）

### 前言

在做数学题时，经常会有需要讨论“特殊情况”的题目。例如，

    任何实数的0次方都是0么？

答案是否定的——0的0次方是一个未定义的数，它没有意义。这件事情就是所有涉及到“某个数的0次方”的数学问题的一个边界条件。任何一个数学家在面对某个数的0次方时，都要仔细地考虑：这个底数是否可能是0？这个“某个数的0次方”是否可能没有意义？如果忘记考虑这一边界条件，就可能犯下大错。

下面用一道编程题目来说明这个问题。

### 例题：进制转换
（出处：清澄Tsinsen网络自动评测系统 公共题库）

<a href="http://tsinsen.com/A1011">点我进入题目页面</a>
#### 问题描述
十六进制数是在程序设计时经常要使用到的一种整数的表示方式。它有0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F共16个符号，分别表示十进制数的0至15。十六进制的计数方法是满16进1，所以十进制数16在十六进制中是10，而十进制的17在十六进制中是11，以此类推，十进制的30在十六进制中是1E。
给出一个非负整数，将它表示成十六进制的形式。
#### 输入格式
输入包含一个非负整数a，表示要转换的数。0<=a<=2147483647
#### 输出格式
输出这个整数的16进制表示。
#### 样例输入
30
#### 样例输出
1E

#### 分析
入门任何一门语言，尤其是入门编程最重要的就是多加练习。笔者非常真心地建议每一个读者都自己思考一下这道题的做法，最好是亲自写了代码之后，到上面提到的这道题的出处那里试着提交并且评测一下试试，接着再来看下面的“剧透”内容。注意——需要先在那里注册登陆，才能看到题目。不过这一切是免费的，请尽管去试试吧！

进制转换只要采用短除法就可以简单地实现——例如把十进制数转换为十六进制数，只要把这个数除以16，得到的余数就是这个数16进制表示的最低位。之后对得到的商重复这个过程（直到某一次得到的商变成了0），就从低位到高位地得到了这个数的16进制表示。希望大家仔细想想，把这个过程理解清楚。

例如，对于上面样例输入的30，先有

    30 ÷ 16 = 1 余 14 // 14就是16进制下的E。接下来对商“1”继续这个过程：
    1 ÷ 16 = 1 余 0 <-- 算法终止！

把两次计算得到的商倒序放置，就得到**1E**，与样例输出符合。

笔者做这道题的时候，很快地便沿着这个思路开始写，写出了下面这样的代码：

```c++
#include <iostream>
using namespace std;
int main(int argc, char **argv)
{
    int a, w[20], digi = 0;
    cin >> a;
    while(a)
    {
        w[digi] = a % 16; // 用数组w来记录每次得到的商
        digi++;
        a = a / 16;
    }
    for(int j = digi - 1; j >= 0; j--)
    {
        if(w[j] >= 10)
            cout << char('A' + w[j] - 10); // 把大于9的数转化为16进制的字母
        else
            cout << w[j]; 
    }
    cout << endl;
    return 0;
}
```

当然了，OJ很快地就给笔者的程序标记了**WrongAnswer**。那之后，笔者想了很久很久，终于把问题解决了。读者可以试着找出程序的问题所在，并提出一个可行的解决方案，发到课程的评论区和其他学习者们讨论交流。相信这一定难不倒你！

### 思考题：反方向的进制转换
题目出处：清澄Tsinsen网络自动评测系统 公共题库

<a href="http://tsinsen.com/A1013">点我进入题目页面</a>
#### 问题描述
从键盘输入一个不超过8位的正的十六进制数字符串，将它转换为正的十进制数后输出。
注：十六进制数中的10~15分别用大写的英文字母A、B、C、D、E、F表示。
#### 样例输入
FFFF
#### 样例输出
65535
#### 分析
下面是笔者写的一份**有bug的程序**。大家可以找出其中存在的问题，并提出可行的解决方案么！欢迎在题目讨论区交流~

```c++
#include <iostream>
using namespace std;

int num[15];

int write_in()
{
    char x;
    int i = 0;
    while(scanf("%c", &x) != EOF && x != '\n')
    {
        i++;
        if(x >= 'A' && x <= 'Z')
            num[i] = x - 'A' + 10;
        else
            num[i] = x - '0';
    }
    return i;
}

int main(int argc, char *argv[])
{
    int digit = write_in();
    int n = 0;
    for(int i = 0; i <= digit; ++i)
    {
        n = n * 16 + num[i];
    }
    cout << n << endl;
    return 0;
}
```

**提示**：下面是几种常见的“边界情况”（当然了，笔者所列一定不完全，也欢迎大家在讨论区发帖对其进行补充）：

1，极端数据，例如数字处理问题中的0、字符串处理问题中可能存在的“空行”等等。

2，过大的数据：超过了数据类型可以表达的最大范围的数据，例如int可以表示-2147483648到2147483647中的整数，超过该范围的数都会变成错误的值。

3，一些复杂问题中的极端情况。

